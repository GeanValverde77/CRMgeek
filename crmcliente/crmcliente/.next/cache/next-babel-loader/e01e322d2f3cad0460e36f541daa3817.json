{"ast":null,"code":"\"use strict\";\n\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nexports.__esModule = true;\nexports.observeLayoutShift = observeLayoutShift;\nexports.observeLargestContentfulPaint = observeLargestContentfulPaint;\nexports.observePaint = observePaint;\nfunction isTypeSupported(type) {\n  if (self.PerformanceObserver && PerformanceObserver.supportedEntryTypes) {\n    return PerformanceObserver.supportedEntryTypes.includes(type);\n  }\n  return false;\n}\nfunction observeLayoutShift(onPerfEntry) {\n  if (isTypeSupported('layout-shift')) {\n    var cumulativeScore = 0;\n    var observer = new PerformanceObserver(function (list) {\n      var _iterator = _createForOfIteratorHelper(list.getEntries()),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var entry = _step.value;\n          // Only count layout shifts without recent user input.\n          if (!entry.hadRecentInput) {\n            cumulativeScore += entry.value;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    });\n    observer.observe({\n      type: 'layout-shift',\n      buffered: true\n    });\n    document.addEventListener('visibilitychange', function clsObserver() {\n      if (document.visibilityState === 'hidden') {\n        // Force any pending records to be dispatched.\n        observer.takeRecords();\n        observer.disconnect();\n        document.removeEventListener('visibilitychange', clsObserver, true);\n        onPerfEntry({\n          name: 'cumulative-layout-shift',\n          value: cumulativeScore\n        });\n      }\n    }, true);\n  }\n}\nfunction observeLargestContentfulPaint(onPerfEntry) {\n  if (isTypeSupported('largest-contentful-paint')) {\n    // Create a variable to hold the latest LCP value (since it can change).\n    var lcp; // Create the PerformanceObserver instance.\n    var observer = new PerformanceObserver(function (entryList) {\n      var entries = entryList.getEntries();\n      var lastEntry = entries[entries.length - 1];\n      lcp = lastEntry.renderTime || lastEntry.loadTime;\n    });\n    observer.observe({\n      type: 'largest-contentful-paint',\n      buffered: true\n    });\n    document.addEventListener('visibilitychange', function lcpObserver() {\n      if (lcp && document.visibilityState === 'hidden') {\n        document.removeEventListener('visibilitychange', lcpObserver, true);\n        onPerfEntry({\n          name: 'largest-contentful-paint',\n          value: lcp\n        });\n      }\n    }, true);\n  }\n}\nfunction observePaint(onPerfEntry) {\n  var observer = new PerformanceObserver(function (list) {\n    list.getEntries().forEach(onPerfEntry);\n  });\n  observer.observe({\n    type: 'paint',\n    buffered: true\n  });\n}","map":null,"metadata":{},"sourceType":"script"}